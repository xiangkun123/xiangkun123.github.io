<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[markdownNote]]></title>
    <url>%2Fmarkdown%2FmarkdownNote%2F</url>
    <content type="text"><![CDATA[Markdown 语法：一、概念： Markdown 语法旨在成为一种适用于网络书写的语言。 Markdown 并不是要取代 HTML， 它只是涵盖了 HTML的一小部分标记。Markdown 的理念是，能让文档更容易读、写和随意改。 Markdown 兼容 HTML，在Markdown涵盖范围之外的内容，都可以使用 HTML 来编写，并且不需要额外标注区分 Markdown 和 Html。直接加标签就OK。 Markdown 中的特殊字符自动转换。在 HTML 中如果你要打印出 &lt; 和 &amp;，那么你必须实体的形式 &amp;lt; 和 &amp;amp;。但是在 Markdown 中你可以很容易书写字符。如果你使用的 &amp; 字符是 HTML 字符实体的一部分，它会不进行转换保留原状，否则它会被转换成 &amp;amp。所以你如果要在文档中插入一个版权符号 ©，你可以这样写：12&amp;copy;` Markdown 会不会转换，保留它不动。而若你写：1AT&amp;T Markdown 就会自动将它转为：1AT&amp;amp;T 类似的状况也会发生在 &lt; 符号上，因为 Markdown 允许兼容 HTML ，如果你是把 &lt; 符号作为 HTML 标签的定界符使用，那 Markdown 也不会对它做任何转换，但是如果你写：14 &lt; 5 Markdown 将会把它转换为：14 &amp;lt; 5 这里还有一点需要注意。如果是在 &lt;code&gt; 标签范围内，&lt; 和 &amp; 都会被转换为实体。 二、区块元素：(1) 段落： 一个或多个连续的文本行的前后要有一个以上的空行才会分段，但其实这是 Markdown 允许段落内的强迫换行。（空行：该行只有一个空格或者制表符就会被认为是空行）。例如：(一二之间隔了一个空行) 这是第一段 这是第二段 但是如果你确实想要依赖 Markdown 来插入 &lt;br /&gt; 标签的话，在插入处先按入两个以上的空格然后回车。 (2) 标题: Markdown 支持两种标题的语法，类 Setext 和类 atx 形式。 类 Setext 形式是用底线的形式，利用 = （最高阶标题）和 - （第二阶标题），任何数量的 = 和 - 都可以有效果。例如：12345This is an H1=============This is an H2------------- 效果: This is an H1This is an H2类 Atx 形式则是在行首插入 1 到 6 个 # ，对应到标题 1 到 6 阶，例如：12345# 这是 H1## 这是 H2###### 这是 H6 效果： 这是 H1这是 H2这是 H6(3) 区块引用：当需要在某处引用一段内容时，可以通过 &gt; 来引用 例如：1&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet, 效果: This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet. 如果是多层引用, 那么就多加几个 &gt;，如此类推。 这是第一层 这是第二层 (4) 列表： Markdown 支持有序列表和无序列表。 无序列表使用 +、-、* 作为列表标记都可以, 标记与文字之间有一个空格： 例如：123+ Red- Green* Yellow 效果： Red Green Yellow 有序列表则使用数字接着一个英文句点： 例如：1231. Red2. Green3. Yellow 效果： Red Green Yellow (5) 代码区段123单行代码 `代码内容`多行代码 代码内容 12345678```效果如下：单行` create database hero;`多行 function fun() { console.log(‘多行’);}fun();123456789101112131415**(6) 字体：**+ 斜体要倾斜的问题左右分别用一个 * 号或者 _ 号包起来+ 加粗要加粗的文字左右分别用两个 * 号或者 _ 号包起来+ 斜体加粗要倾斜加粗的字体左右分别用三个 * 号包起来+ 删除线要加删除线的文字左右分别用两个 ~~ 号包起来例子： *倾斜字体* _倾斜字体_ **加粗字体** __加粗字体__ ***倾斜加粗字体*** ~~删除线字体~~ 1234567891011121314151617181920效果：*倾斜字体*_倾斜字体_**加粗字体**__加粗字体__***倾斜加粗字体***~~删除线字体~~**(7) 分割线：**三个或者三个以上的 - 或者 * 或者 _ (加空格便于显示)都可以例子： 123456789101112131415效果一样:-------*******_ _ _## 三、 区段元素：**(1) 超链接：** 超链接有两种方式: **行内式** 和 **参考式**&gt;行内式例子： 超链接名title 可不加1234567效果:这是一个 [百度](http://www.baidu.com &quot;百度&quot;) 的链接地址这是一个 [淘宝](http://www.taobao.com) 的链接地址&gt;参考式例子： I get 10 times more traffic from Google than fromYahoo or MSN. 1如果改成用链接名称的方式写：（第二个 [] 中不写 id 值默认和第一个 [] 中的名称一致） I get 10 times more traffic from Google than fromYahoo or MSN. 12345678910111213产生的效果是一样的：I get 10 times more traffic from [Google][] than from[Yahoo][] or [MSN][]. [google]: http://google.com/ &quot;Google&quot; [yahoo]: http://search.yahoo.com/ &quot;Yahoo Search&quot; [msn]: http://search.msn.com/ &quot;MSN Search&quot;**(2) 图片链接：**图片链接同样有两种形式: **行内式** 和 **参考式**&gt;行内式例子： 图片alt 就是图片不显示时显示的文字内容，相当于描述 图片title 就是图片的标题, 鼠标移到上面去时会显示，可加可不加12345效果:![百度图片](./markdownNote/demo.jpeg &quot;百度图片&quot;)&gt;参考式例子： 1「id」是图片参考的名称，图片参考的定义方式则和链接参考一样： 12345到目前为止， Markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的 &lt;img&gt; 标签。**(3) 表格：**例子： 姓名 技能 排行 刘备 哭 大哥 关羽 打 二哥 张三 骂 三弟 第二行分隔表头和内容文字默认居左-两边加： 表示文字居中-右边加： 表示文字居右注: 原生的语法两边都要用 | 包起来，这里省略；不同网站的编辑器对于markdown的支持不同，表格流程图可能会有差异。 `效果: 姓名 技能 排行 刘备 哭 大哥 关羽 打 二哥 张三 骂 三弟 (4) 流程图：vs code 中暂没找到方法显示，先不弄]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[scriptOJ系列题]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%E9%A2%98%E5%BA%93%2FscriptOJ%2F</url>
    <content type="text"><![CDATA[scriptOJ 系列算法题集题目一：extname 是 nodejs 中用于返回文件后缀名的方法。请编写一个类似 extname 函数，它会接受一个文件名作为参数，你需要返回它的扩展名。 例如，输入 emoji.png，返回 .png。 思路：首先通过正则判断当前文件名是否有后缀名，如果存在就截取最后的一段截取内容即可，否则返回空。 123456789const extname = (filename) =&gt; &#123; var exp = /(\S)+\.(\S)+/; if(exp.test(filename))&#123; var arr = filename.split(&apos;.&apos;); return &apos;.&apos; + arr[arr.length - 1]; &#125; else &#123; return &apos;&apos; &#125;&#125; continue…]]></content>
      <categories>
        <category>算法题库</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法题库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写一个方法将一个数组随机打乱]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%E9%A2%98%E5%BA%93%2Fcalculation%2F</url>
    <content type="text"><![CDATA[(1) 写一个方法将一个数组随机打乱 例如： arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]，通过一个方法 randFun = func(arr)，返回一个新的数组 newArr = [2, 1, 4, 3, 5, 6, 7, 10, 8, 9]。 方法一：sort排序法（最简单的打乱数组顺序的方法）1234利用sort用法：arr.sort(compareFunction) 如果 compareFunction(a,b) 返回的值大于 0 ，则 b 在 a 的前边； 如果 compareFunction(a,b) 返回的值等于 0 ，则a 、b 位置保持不变； 如果 compareFunction(a,b) 返回的值小于 0 ，则 a 在 b 的前边。 常见写法如下：12345678910111213141516// ES5:let arr = [1, 2, 3, 4, 5];function randFun(arr) &#123; arr.sort(function () &#123; return Math.random() - 0.5; &#125;);&#125;let newArr = randFun(arr);// ES6：let arr = [1, 2, 3, 4, 5];let newArr = arr =&gt; arr.sort(() =&gt; Math.random() - 0.5);// 引申：let arr = [1, 2, 3, 4, 5];let newArr = arr =&gt; arr.sort(() =&gt; Math.random() - Math.random()); 但是这种方法有个弊端，它并不能真正地随机打乱数组。 弊端看下面的代码，我们生成一个长度为 10 的数组[‘a’, ‘b’, ‘c’, ‘d’, ‘e’, ‘f’, ‘g’, ‘h’, ‘i’, ‘j’]，使用上面的方法将数组乱序，执行多次后，会发现每个元素仍然有很大机率在它原来的位置附近出现。 12345678910111213let n = 10000;// 创建一个储存计算结果的数组let count = (new Array(10)).fill(0);// 计算 a 出现在每个位置上的次数for (let i = 0; i &lt; n; i ++) &#123; let arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;, &apos;g&apos;, &apos;h&apos;, &apos;i&apos;, &apos;j&apos;]; arr.sort(() =&gt; Math.random() - 0.5); count[arr.indexOf(&apos;a&apos;)]++;&#125;console.log(count); 输出[ 2891, 2928, 1927, 1125, 579, 270, 151, 76, 34, 19 ]（带有一定随机性，每次结果都不同，但大致分布应该一致），即进行 10000 次排序后，字母’a’（数组中的第一个元素）有约 2891 次出现在第一个位置、2928 次出现在第二个位置，与之对应的只有 19 次出现在最后一个位置。如果把这个分布绘制成图像，会是下面这样： 类似地，我们可以算出字母’f’（数组中的第六个元素）在各个位置出现的分布为[ 312, 294, 579, 1012, 1781, 2232, 1758, 1129, 586, 317 ]，图像如下： 如果排序真的是随机的，那么每个元素在每个位置出现的概率都应该一样，实验结果各个位置的数字应该很接近，而不应像现在这样明显地集中在原来位置附近。因此，可以认为，使用形如arr.sort(() =&gt; Math.random() - 0.5)这样的方法得到的并不是真正的随机排序。 方法二：循环随机位交换法（最容易理解的打乱数组顺序的方法） 原理：循环遍历该数组，在每次遍历中产生一个(0 ~ length - 1)之间的随机下标的数，该数代表本次循环要随机交换的位置。将本次循环当前位置的数和随机位置的数进行交换。 1234567891011let arr = [1, 2, 3, 4, 5];function randFun(arr) &#123; for(let i=0, len = arr.length; i &lt; len; i++) &#123; let index = parseInt(Math.random() * (len - 1)); let tempValue = arr[i]; arr[i] = arr[index]; arr[index] = tempValue; &#125; return arr;&#125;let newArr = randFun(arr); 方法三：Fisher–Yates 洗牌算法 和方法二类似 1234567891011121314151617181920ES6：function shuffle(arr) &#123; let i = arr.length; while (i) &#123; let j = Math.floor(Math.random() * i--); [arr[j], arr[i]] = [arr[i], arr[j]]; &#125;&#125;ES5:function shuffle(arr) &#123; var i = arr.length, t, j; while (i) &#123; j = Math.floor(Math.random() * i--); t = arr[i]; arr[i] = arr[j]; arr[j] = t; &#125;&#125; 总结： 如果是循环内容次数比较少的时候，可以取巧地使用方法一，写法比较简单，容易记忆； 如果是在循环次数较多的情况下，使用方法一不好，可以选择使用方法二或者方法三。]]></content>
      <categories>
        <category>算法题库</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法题库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+github搭建个人博客]]></title>
    <url>%2F%E5%8D%9A%E5%AE%A2%2Fhexo%2Bgithub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[简单了解GitHub Page 是什么Github Page是面向用户、组织和项目开放的公共静态页面搭建托管服务，站点可以被免费托管在Github上 Hexo是什么你可以将你的静态页面直接放在Github Page上，也可以用Hexo或者Jekyll等博客框架自动生成站点。 Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 安装前提安装 hexo 前必须确保你的电脑已经安装了 Node.js 和 git： Nodejs git Hexo这里我选择在我的 F 盘下创建一个 hexo 目录，以下操作默认是在 F:/hexo 下进行 安装1npm install -g hexo-cli 初始化 1hexo init [folder] folder 是你项目的文件夹，这里我的 folder 目录名为 my-blog，如果不写 folder名称，那么默认在当前文件夹初始化。 1cd my-blog 生成静态文件需要执行 generate 命令生成静态文件，才能部署到服务器 1hexo generate (hexo g 也可以) 启动服务器由于还没有配置 Github，所以我们先部署到本地服务器 1hexo server (hexo s 也可以) 默认情况下，访问网址为： http://localhost:4000/在某些情况下，你可能4000的端口被占用，可以选择重设端口 1hexo -p 5000 server 这样的话地址就变成了 http://localhost:5000/ 打开浏览器，输入地址你就可以看到你初始的博客啦。 目录结构 _config.yml : 网站的配置信息，您可以在此配置大部分的参数 package.json: 应用程序的信息。可以查看安装了那些包文件 scaffolds: 模版文件夹。Hexo 会根据 scaffold 来建立文件 source: 资源文件夹。是存放用户资源的地方 themes: 主题 文件夹。Hexo 会根据主题来生成静态页面。 hexo 详细配置请查看 官网 Github Page 配置接下来，我们来操作如何将Hexo部署到Github Page上 创建 Github 仓库创建与你的 Github 用户名相对应的 Github Page 仓库，格式必须是 username.github.io，其中 username 必须是你的用户名，其他的都无效。 建立关联进入你刚创建的仓库，复制仓库的地址 ssh设置比较麻烦还容易出错，这里建议新手选择 HTTPS 地址 打开 my-blog 文件夹下的 _config.yml 文件，拉倒最下面，修改 deploy 为以下代码，repository 后面的是你的仓库地址 1234deploy: type: git repo: https://github.com/xiangkun123/xiangkun123.github.io.git branch: master 这里需要注意的是，Github仓库有两种连接方式： HTTPS：每次上传到仓库都需要输入账号密码 SSH：不用每次上传后输入账号密码，但需要配置 SSH Key 这两者的区别： 前者可以随意克隆github上的项目，而不管是谁的；而后者则是你必须是你要克隆的项目的拥有者或管理员，且需要先添加 SSH key ，否则无法克隆。 https url 在push的时候是需要验证用户名和密码的；而 SSH 在push的时候，是不需要输入用户名的，如果配置SSH key的时候设置了密码，则需要输入密码的，反之是不需要输入密码的 这里简单介绍一下如何配置 ssh（选择 https 的可跳过）目录下打开您的 git-bash（右键打开 git Bash Here）,接着按照下面步骤： (1) 检查SSH keys的设置: 首先我们需要检查你电脑上现有的ssh key： 1cd ~/.ssh 如果显示“No such file or directory”，跳到第三步，否则继续。 (2) 备份和移除原来的ssh key设置: 因为已经存在key文件，所以需要备份旧的数据并删除： 12345$ lsconfig id_rsa id_rsa.pub known_hosts$ mkdir key_backup$ cp id_rsa* key_backup$ rm id_rsa* (3) 生成新的SSH Key： 123$ ssh-keygen -t rsa -C &quot;您的邮件地址@youremail.com&quot;Generating public/private rsa key pair.Enter file in which to save the key (/Users/your_user_directory/.ssh/id_rsa): &lt;回车就好&gt; 然后系统会要你输入加密串（Passphrase）： 12Enter passphrase (empty for no passphrase):&lt;输入加密串&gt;Enter same passphrase again:&lt;再次输入加密串&gt; 这里建议加密串也直接回车。 最后看到这样的大概界面，就成功设置ssh key了： (4) 验证一下1$ ssh -T git@github.com 出现如下消息，证明成功： 有时可能会报错，如下图： 把 known_hosts 文件内容修改为格式如下的内容即可 1github.com,警告中提示的IP地址 id_rsa.pub的内容 其中可以在图中看到我们的 id_rsa.pub 保存在了 /c/Users/lenovo/.ssh/id_rsa.pub 下，打开对应的目录，文本编辑器打开 id_rsa.pub 文件，复制里面的内容； 在创建的 github 项目中，选择 Settings &gt; Deploy keys &gt; Add deploy key，接着填上 ”title“ 和 Key (粘贴 id_rsa.pub 中的内容)，点击 ”Add key“ 完成，出现一个 key 表示成功添加，如果没有反应代表你添加失败。 部署执行以下命令安装 hexo-deployer-git，安装完才能使用 git 部署 1npm install hexo-deployer-git --save 输入以下命令部署到 Github Page 1hexo deploy 接着，在 github 上打开刚才创建的目录，等待几分钟就能发现代码已经上传后，这时就可以打开你的网站站点 https://username.github.io/ 查看到页面。 之后重新部署三步123hexo cleanhexo ghexo d 搭建完成至此，独立博客就算搭建完成。 新建一篇文章 hexo new [layout] &lt;title&gt; 您可以在命令中指定文章的布局（layout），默认为 post，可以通过修改 _config.yml 中的 default_layout 参数来指定默认布局。更多可查看官网。 本地调试 hexo server –debug (或者 hexo s –debug) 然后就可以打开本地地址 http://localhost:4000/ 调试编写的文章了。]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
</search>
