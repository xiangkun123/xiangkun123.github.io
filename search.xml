<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[写一个方法将一个数组随机打乱]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%E9%A2%98%E5%BA%93%2Fcalculation%2F</url>
    <content type="text"><![CDATA[(1) 写一个方法将一个数组随机打乱 例如： arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]，通过一个方法 randFun = func(arr)，返回一个新的数组 newArr = [2, 1, 4, 3, 5, 6, 7, 10, 8, 9]。 方法一：sort排序法（最简单的打乱数组顺序的方法）1234利用sort用法：arr.sort(compareFunction) 如果 compareFunction(a,b) 返回的值大于 0 ，则 b 在 a 的前边； 如果 compareFunction(a,b) 返回的值等于 0 ，则a 、b 位置保持不变； 如果 compareFunction(a,b) 返回的值小于 0 ，则 a 在 b 的前边。 常见写法如下：12345678910111213141516// ES5:let arr = [1, 2, 3, 4, 5];function randFun(arr) &#123; arr.sort(function () &#123; return Math.random() - 0.5; &#125;);&#125;let newArr = randFun(arr);// ES6：let arr = [1, 2, 3, 4, 5];let newArr = arr =&gt; arr.sort(() =&gt; Math.random() - 0.5);// 引申：let arr = [1, 2, 3, 4, 5];let newArr = arr =&gt; arr.sort(() =&gt; Math.random() - Math.random()); 但是这种方法有个弊端，它并不能真正地随机打乱数组。 弊端看下面的代码，我们生成一个长度为 10 的数组[‘a’, ‘b’, ‘c’, ‘d’, ‘e’, ‘f’, ‘g’, ‘h’, ‘i’, ‘j’]，使用上面的方法将数组乱序，执行多次后，会发现每个元素仍然有很大机率在它原来的位置附近出现。 12345678910111213let n = 10000;// 创建一个储存计算结果的数组let count = (new Array(10)).fill(0);// 计算 a 出现在每个位置上的次数for (let i = 0; i &lt; n; i ++) &#123; let arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;, &apos;g&apos;, &apos;h&apos;, &apos;i&apos;, &apos;j&apos;]; arr.sort(() =&gt; Math.random() - 0.5); count[arr.indexOf(&apos;a&apos;)]++;&#125;console.log(count); 输出[ 2891, 2928, 1927, 1125, 579, 270, 151, 76, 34, 19 ]（带有一定随机性，每次结果都不同，但大致分布应该一致），即进行 10000 次排序后，字母’a’（数组中的第一个元素）有约 2891 次出现在第一个位置、2928 次出现在第二个位置，与之对应的只有 19 次出现在最后一个位置。如果把这个分布绘制成图像，会是下面这样： 类似地，我们可以算出字母’f’（数组中的第六个元素）在各个位置出现的分布为[ 312, 294, 579, 1012, 1781, 2232, 1758, 1129, 586, 317 ]，图像如下： 如果排序真的是随机的，那么每个元素在每个位置出现的概率都应该一样，实验结果各个位置的数字应该很接近，而不应像现在这样明显地集中在原来位置附近。因此，可以认为，使用形如arr.sort(() =&gt; Math.random() - 0.5)这样的方法得到的并不是真正的随机排序。 方法二：循环随机位交换法 原理：循环遍历该数组，在每次遍历中产生一个(0 ~ length - 1)之间的随机下标的数，该数代表本次循环要随机交换的位置。将本次循环当前位置的数和随机位置的数进行交换。 1234567891011let arr = [1, 2, 3, 4, 5];function randFun(arr) &#123; for(let i=0, len = arr.length; i &lt; len; i++) &#123; let index = parseInt(Math.random() * (len - 1)); let tempValue = arr[i]; arr[i] = arr[index]; arr[index] = tempValue; &#125; return arr;&#125;let newArr = randFun(arr); 方法三：Fisher–Yates 洗牌算法 和方法二类似 1234567891011121314151617181920ES6：function shuffle(arr) &#123; let i = arr.length; while (i) &#123; let j = Math.floor(Math.random() * i--); [arr[j], arr[i]] = [arr[i], arr[j]]; &#125;&#125;ES5:function shuffle(arr) &#123; var i = arr.length, t, j; while (i) &#123; j = Math.floor(Math.random() * i--); t = arr[i]; arr[i] = arr[j]; arr[j] = t; &#125;&#125; 总结： 如果是循环内容次数比较少的时候，可以取巧地使用方法一，写法比较简单，容易记忆； 如果是在循环次数较多的情况下，使用方法一不好，可以选择使用方法二或者方法三。]]></content>
      <categories>
        <category>算法题库</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法题库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+github搭建个人博客]]></title>
    <url>%2F%E5%8D%9A%E5%AE%A2%2Fhexo%2Bgithub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[简单了解GitHub Page 是什么Github Page是面向用户、组织和项目开放的公共静态页面搭建托管服务，站点可以被免费托管在Github上 Hexo是什么你可以将你的静态页面直接放在Github Page上，也可以用Hexo或者Jekyll等博客框架自动生成站点。 Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 安装前提安装 hexo 前必须确保你的电脑已经安装了 Node.js 和 git： Nodejs git Hexo这里我选择在我的 F 盘下创建一个 hexo 目录，以下操作默认是在 F:/hexo 下进行 安装1npm install -g hexo-cli 初始化 1hexo init [folder] folder 是你项目的文件夹，这里我的 folder 目录名为 my-blog，如果不写 folder名称，那么默认在当前文件夹初始化。 1cd my-blog 生成静态文件需要执行 generate 命令生成静态文件，才能部署到服务器 1hexo generate (hexo g 也可以) 启动服务器由于还没有配置 Github，所以我们先部署到本地服务器 1hexo server (hexo s 也可以) 默认情况下，访问网址为： http://localhost:4000/在某些情况下，你可能4000的端口被占用，可以选择重设端口 1hexo -p 5000 server 这样的话地址就变成了 http://localhost:5000/ 打开浏览器，输入地址你就可以看到你初始的博客啦。 目录结构 _config.yml : 网站的配置信息，您可以在此配置大部分的参数 package.json: 应用程序的信息。可以查看安装了那些包文件 scaffolds: 模版文件夹。Hexo 会根据 scaffold 来建立文件 source: 资源文件夹。是存放用户资源的地方 themes: 主题 文件夹。Hexo 会根据主题来生成静态页面。 hexo 详细配置请查看 官网 Github Page 配置接下来，我们来操作如何将Hexo部署到Github Page上 创建 Github 仓库创建与你的 Github 用户名相对应的 Github Page 仓库，格式必须是 username.github.io，其中 username 必须是你的用户名，其他的都无效。 建立关联进入你刚创建的仓库，复制仓库的地址 ssh设置比较麻烦还容易出错，这里建议新手选择 HTTPS 地址 打开 my-blog 文件夹下的 _config.yml 文件，拉倒最下面，修改 deploy 为以下代码，repository 后面的是你的仓库地址 1234deploy: type: git repo: https://github.com/xiangkun123/xiangkun123.github.io.git branch: master 这里需要注意的是，Github仓库有两种连接方式： HTTPS：每次上传到仓库都需要输入账号密码 SSH：不用每次上传后输入账号密码，但需要配置 SSH Key 这两者的区别： 前者可以随意克隆github上的项目，而不管是谁的；而后者则是你必须是你要克隆的项目的拥有者或管理员，且需要先添加 SSH key ，否则无法克隆。 https url 在push的时候是需要验证用户名和密码的；而 SSH 在push的时候，是不需要输入用户名的，如果配置SSH key的时候设置了密码，则需要输入密码的，反之是不需要输入密码的 这里简单介绍一下如何配置 ssh（选择 https 的可跳过）目录下打开您的 git-bash（右键打开 git Bash Here）,接着按照下面步骤： (1) 检查SSH keys的设置: 首先我们需要检查你电脑上现有的ssh key： 1cd ~/.ssh 如果显示“No such file or directory”，跳到第三步，否则继续。 (2) 备份和移除原来的ssh key设置: 因为已经存在key文件，所以需要备份旧的数据并删除： 12345$ lsconfig id_rsa id_rsa.pub known_hosts$ mkdir key_backup$ cp id_rsa* key_backup$ rm id_rsa* (3) 生成新的SSH Key： 123$ ssh-keygen -t rsa -C &quot;您的邮件地址@youremail.com&quot;Generating public/private rsa key pair.Enter file in which to save the key (/Users/your_user_directory/.ssh/id_rsa): &lt;回车就好&gt; 然后系统会要你输入加密串（Passphrase）： 12Enter passphrase (empty for no passphrase):&lt;输入加密串&gt;Enter same passphrase again:&lt;再次输入加密串&gt; 这里建议加密串也直接回车。 最后看到这样的大概界面，就成功设置ssh key了： (4) 验证一下1$ ssh -T git@github.com 出现如下消息，证明成功： 有时可能会报错，如下图： 把 known_hosts 文件内容修改为格式如下的内容即可 1github.com,警告中提示的IP地址 id_rsa.pub的内容 其中可以在图中看到我们的 id_rsa.pub 保存在了 /c/Users/lenovo/.ssh/id_rsa.pub 下，打开对应的目录，文本编辑器打开 id_rsa.pub 文件，复制里面的内容； 在创建的 github 项目中，选择 Settings &gt; Deploy keys &gt; Add deploy key，接着填上 ”title“ 和 Key (粘贴 id_rsa.pub 中的内容)，点击 ”Add key“ 完成，出现一个 key 表示成功添加，如果没有反应代表你添加失败。 部署执行以下命令安装 hexo-deployer-git，安装完才能使用 git 部署 1npm install hexo-deployer-git --save 输入以下命令部署到 Github Page 1hexo deploy 接着，在 github 上打开刚才创建的目录，等待几分钟就能发现代码已经上传后，这时就可以打开你的网站站点 https://username.github.io/ 查看到页面。 之后重新部署三步123hexo cleanhexo ghexo d 搭建完成至此，独立博客就算搭建完成。]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
</search>
